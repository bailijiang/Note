<!-- MarkdownTOC -->

- [1. UML 建模](#1-uml-建模)
- [2. 泛化关系](#2-泛化关系)
- [3. 依赖/关联关系](#3-依赖关联关系)
- [4. 聚合\(Aggregation\) / 组合\(Compositon\) 关联关系](#4-聚合aggregation--组合compositon-关联关系)
- [5. 时序图](#5-时序图)
- [6. 流程图\(活动图\)](#6-流程图活动图)
- [7. 面向对象软件设计模式原则](#7-面向对象软件设计模式原则)
- [8. 简单工厂模式](#8-简单工厂模式)
- [9. 工厂模式](#9-工厂模式)
- [10. 抽象工厂模式](#10-抽象工厂模式)
- [11. 工厂三兄弟](#11-工厂三兄弟)
- [12. 单例模式](#12-单例模式)
- [13. 代理模式](#13-代理模式)
- [14. 装饰器模式](#14-装饰器模式)
- [15. 外观模式](#15-外观模式)
- [16. 适配器模式](#16-适配器模式)
- [17. 模板方法模式](#17-模板方法模式)
- [18. 命令模式](#18-命令模式)
- [19. 策略模式](#19-策略模式)
- [20. 观察者模式](#20-观察者模式)

<!-- /MarkdownTOC -->

<a id="1-uml-建模"></a>
#### 1. UML 建模
* starUML: Project->Model->..Diagram
* 用例图: Use Case
* 类图: Class Case
    - +号 public
    - -号 private
    - \#号 protected

<a id="2-泛化关系"></a>
#### 2. 泛化关系
* 本质: 继承(父子)关系

<a id="3-依赖关联关系"></a>
#### 3. 依赖/关联关系
* 如果一个类的方法的参数或返回值包括另一个类对象, 那这2个类就是依赖关系----->
* 如果一个类的属性是另一个类的对象, 那这2个类就是关联关系$\longrightarrow$

<a id="4-聚合aggregation--组合compositon-关联关系"></a>
#### 4. 聚合(Aggregation) / 组合(Compositon) 关联关系
* 聚合不如组合关系紧密
* 组合关系具有相同的生命周期
* 大雁与雁群是聚合关系, 大雁与雁翅是组合关系

<a id="5-时序图"></a>
#### 5. 时序图
* 可通过starUML: Sequence Diagram 创建

<a id="6-流程图活动图"></a>
#### 6. 流程图(活动图)
* starUML: Activity Diagram

<a id="7-面向对象软件设计模式原则"></a>
#### 7. 面向对象软件设计模式原则
* 目标: 高内聚, 低耦合 (通过多态)
* 单一职责原则: 每个类class的功能尽量单一
* 开闭原则: 类的功能增强通过添加代码实现, 而不是修改class代码
    - 多个单一功能类继承一个抽象类
    - 增加新类class实现功能增强(实现抽象类)
    - 好处: 之前已经写好并测试通过的代码都不需要再修改了
    - class拆分, 一拆多
* 里氏代换原则: 尽量多用抽象类, 多用多态
* 依赖倒转原则: 
    - 依赖于抽象接口, 面向接口编程 .h, 
    - 先写抽象层接口, 抽象类virtual class
    - 业务逻辑层不关心实现层
* 合成复用原则: 组合优先于继承, 避免受父类影响, 降低耦合度
* 迪米特法则: 代理模式, 中介

<a id="8-简单工厂模式"></a>
#### 8. 简单工厂模式
* 将构造方法抽象到工厂类中, 根据标签或条件创建相应的对象
* 通过多态将构造方法与抽象类隔离
* 工厂类: 创建对象方法, 会根据标签返回一个抽象类指针所指向的对象, 实现多态
* 缺点: 违背了开闭原则
* 适用于创建对象较少的场景
```
class Factory {
public:
    //水果生产器
    Fruit * createFruit(string kind) {
        Fruit *fruit = NULL;

        if (kind == "apple") {
            fruit =  new Apple;
        }
        else if(kind == "banana"){
            fruit =  new Banana;
        }
        //添加一个鸭梨   修改了工厂的方法， 违背了开闭原则
        else if (kind == "pear") {
            fruit = new Pear;
        }
        return fruit;
    }
};
```
![](image\简单工厂模式.PNG)

<a id="9-工厂模式"></a>
#### 9. 工厂模式
* 将工厂类进行抽象
* 2次多态: 抽象产品, 抽象工厂

<a id="10-抽象工厂模式"></a>
#### 10. 抽象工厂模式
* 产品族和产品等级结构
    - 产品族: 同一产地 / 同一国家 / 同一系列..., 功能不同的为同一产品族
    - 产品等级结构: 功能相同, 不同厂商/产地/国家/系列..., 为同一产品等级结构
* 在产品非常多的场景下, 可以减少工厂类的数量
* 抽象的工厂，是面向产品族的
* 具体的工厂类, 是面向产品等级的
* 缺点: 所有与工厂相关的(抽象工厂/具体工厂类), 都不符合开闭原则
* 适用场景: 架构层稳定, 即抽象工厂类不会被改变的情况下使用
* 通过架构类聚合产品族对象

<a id="11-工厂三兄弟"></a>
#### 11. 工厂三兄弟
* 简单工厂模式 + "开闭原则" = 工厂方法模式
* 工厂方法模式 + "产品族" = 抽象工厂方法模式
* 简单工厂模式适用于较小规模模型
* 工厂方法模式适用于中等规模模型
* 抽象工厂方法模式适用于大型复杂规模模型

<a id="12-单例模式"></a>
#### 12. 单例模式
* 单例模式的使用步骤:
    - 构造函数私有化 // 为了不让在类的外部再创建一个本类的实例
    - 提供一个全局的静态方法(全局访问点)来获取单例对象
    - 在类中定义一个静态指针, 指向本类的变量的静态变量指针 
```
class Singleton
{
public:
    static Singleton* getInstance()
    {
        // 线程不安全, 需要加锁
        if (instance == NULL)
        {
            instance = new Singleton;
        }
        return instance;
        
    }
private:
    Singleton()
    {

    }
    static Singleton* instance;
};
Singleton* Singleton::instance = NULL;
```
* 使用场景: 
    - 记录日志 Log 
    - 线程池

<a id="13-代理模式"></a>
#### 13. 代理模式
* 代理类要继承实现抽象类, 并且private里包含被代理的父类指针, 构造函数中要传子类对象(多态)
* 通过组合的方式扩展功能, 不适用继承, 这样可以降低耦合度
```
class OverseasProxy :public Shopping
{
public:
    OverseasProxy(Shopping *shpping)
    {
        this->shopping = shpping;
    }

    virtual void buy(Item *it)  {

        //1 辨别商品的真假，
        //2 进行购买（）
        //3 通过海关安检，带回祖国

        if (it->getFact() == true)
        {
            cout << "1 发现正品， 要购物" << endl;

            //用传递进来的购物方式去购物
            shopping->buy(it);


            //3 安检
            cout << "2 通过海关安检， 带回祖国" << endl;
        }
        else {
            cout << "1 发现假货，不会购买" << endl;
        }
        
    }
private:
    Shopping *shopping; //有一个购物方式
};
```
* 三明治模式, 相当于装饰器
* 可以在原有业务的前后添加固定功能
* 应用场景: 添加打日志Log功能

<a id="14-装饰器模式"></a>
#### 14. 装饰器模式
* 装饰器类有抽象类和具体装饰器类
* 使用场景: 在原有业务的前后增加功能, 如Log, backup...

<a id="15-外观模式"></a>
#### 15. 外观模式
* 将包含对象的方法打包
* 使用场景: 为复杂系统提供简单入口

<a id="16-适配器模式"></a>
#### 16. 适配器模式
* 使用场景: 在旧系统中使用新方法, 旧系统的代码不能更改, 又要使用新接口, 就可以通过适配器类解决
* 可以在析构方法中delete匿名对象

<a id="17-模板方法模式"></a>
#### 17. 模板方法模式
* 使用场景: 步骤相同, 具体细节不同时, 可以将步骤抽象出来

<a id="18-命令模式"></a>
#### 18. 命令模式
* 使用场景: 将请求调用者和接收者解耦, 队列缓存, 异步, 需要执行一系列命令时
* 将请求封装成class, 请求class对象可以排队, 可以被撤销
* 将命令/待执行的动作抽象出来, 使请求者和接收者进行隔离
* 相当于回调机制在面向对象中的一种替代品
* 对事务(一组操作)建模的方法

<a id="19-策略模式"></a>
#### 19. 策略模式
* 使用场景: 针对相同的数据采用不同的算法(策略)处理
* 将一系列算法抽象出来, 可以互相替换
* 一个类对象属性是一个抽象父类指针, 根据传参变更策略

<a id="20-观察者模式"></a>
#### 20. 观察者模式
* 使用场景: 
    - MVC中 Model是目标, View是观察者
    - 一个通知者广播消息触发所有观察者改变状态(多态)
* 一种一对多的依赖关系
* 需要注意避免循环调用(触发广播)
